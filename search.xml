<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>不安全的Windows驱动配置</title>
      <link href="/2023/04/23/windows-driver-security-sal/"/>
      <url>/2023/04/23/windows-driver-security-sal/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>寻找驱动中的漏洞一直是Windows平台下进行本地提权LPE的重要途径。但是在挖掘驱动的漏洞之前，首先需要解决的一个问题：攻击者（通常是低权限的用户）如何访问该驱动？<br>通常情况下，</p><h3 id="直接可以通过CreateFile打开设备名称"><a href="#直接可以通过CreateFile打开设备名称" class="headerlink" title="直接可以通过CreateFile打开设备名称"></a>直接可以通过CreateFile打开设备名称</h3><p>造成可以直接访问驱动对原因有：<br>1）驱动安装配置文件inf里没有利用<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/sddl-for-device-objects">SDDL</a>设置合适对ACL，或者<br>2）驱动在创建设备对象时候，调用不安全的API:<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">IoCreateDevice</a>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING  RegistryPath)</span><br><span class="line">&#123;</span><br><span class="line">  UNICODE_STRING DeviceName, SymbolicLink,sddlString;</span><br><span class="line">  PDEVICE_OBJECT deviceObject;</span><br><span class="line">  RtlInitUnicodeString(&amp;DeviceName, <span class="string">L&quot;\\Device\\mydriver&quot;</span>);</span><br><span class="line">  RtlInitUnicodeString(&amp;SymbolicLink, <span class="string">L&quot;\\DosDevices\\mydriver&quot;</span>);</span><br><span class="line">  UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">  <span class="comment">//创建设备</span></span><br><span class="line">  IoCreateDevice(DriverObject, <span class="number">65535</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, FALSE, &amp;deviceObject);  </span><br><span class="line">  <span class="comment">//创建设备的符号连接，以便应用层可以通过该符号连接进行访问</span></span><br><span class="line">  IoCreateSymbolicLink(&amp;SymbolicLink, &amp;DeviceName);</span><br><span class="line">  <span class="comment">//IRP处理例程</span></span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = myInternalDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = myDispatchCreate;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = myDispatchClose;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_READ] = myDispatchRead;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = myDispatchWrite;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = mDispatchCleanup;</span><br><span class="line">  DriverObject-&gt;DriverUnload = myUnloadDriver;</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br>3）驱动在创建设备对象虽然调用了安全对API:<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure">IoCreateDeviceSecure</a>，但SDDL参数配置不恰当，如NULL或者SDDL限制范围过宽</p><h3 id="利用上层应用对漏洞进行访问"><a href="#利用上层应用对漏洞进行访问" class="headerlink" title="利用上层应用对漏洞进行访问"></a>利用上层应用对漏洞进行访问</h3><p>至少有三种可能：<br>1）驱动对上层应用存在任意代码执行（低权限），或者<br>2）上层应用的逻辑漏洞，导致第三方应用可以访问驱动，或者<br>3）驱动对访问对象有校验机制，但是可被绕过。比如驱动仅仅校验了进程名，这时候可以简单通过同名进程绕过，如果驱动进行签名校验，那么攻击者还可以尝试通过进程注入方式绕过</p><h3 id="利用设备空间间接访问驱动"><a href="#利用设备空间间接访问驱动" class="headerlink" title="利用设备空间间接访问驱动"></a>利用设备空间间接访问驱动</h3><p>这也是本博客重点要介绍的一个漏洞模式</p><h2 id="安全API-IoCreateDeviceSecure的不安全使用"><a href="#安全API-IoCreateDeviceSecure的不安全使用" class="headerlink" title="安全API IoCreateDeviceSecure的不安全使用"></a>安全API IoCreateDeviceSecure的不安全使用</h2><p>一般情况下，开发者都会进行以下编码，以便对驱动对象对访问实施控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING  RegistryPath)</span><br><span class="line">&#123;</span><br><span class="line">  UNICODE_STRING DeviceName, SymbolicLink,sddlString;</span><br><span class="line">  PDEVICE_OBJECT deviceObject;</span><br><span class="line">  RtlInitUnicodeString(&amp;DeviceName, <span class="string">L&quot;\\Device\\mydriver&quot;</span>);</span><br><span class="line">  RtlInitUnicodeString(&amp;SymbolicLink, <span class="string">L&quot;\\DosDevices\\mydriver&quot;</span>);</span><br><span class="line">  <span class="comment">//设置安全访问对SDDL，以下是最常见的配置，表示仅管理员和SYSTEM对进程可以访问</span></span><br><span class="line">  RtlInitUnicodeString(&amp;sddlString, <span class="string">L&quot;D:P(A;;GA;;;SY)(A;;GA;;;BA)&quot;</span>);</span><br><span class="line">  UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">  <span class="comment">//创建设备</span></span><br><span class="line">  IoCreateDeviceSecure(DriverObject, , &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="literal">NULL</span>, FALSE, &amp;sddlString, <span class="literal">NULL</span>, &amp;deviceObject);  </span><br><span class="line">  <span class="comment">//创建设备的符号连接，以便应用层可以通过该符号连接进行访问</span></span><br><span class="line">  IoCreateSymbolicLink(&amp;SymbolicLink, &amp;DeviceName);</span><br><span class="line">  <span class="comment">//IRP处理例程</span></span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = myInternalDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = myDispatchCreate;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = myDispatchClose;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_READ] = myDispatchRead;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = myDispatchWrite;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = myDispatchCleanup;</span><br><span class="line">  DriverObject-&gt;DriverUnload = myUnloadDriver;</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，开发者认为已经调用了安全的API：IoCreateDeviceSecure，同时也设置合理的SDDL：”D:P(A;;GA;;;SY)(A;;GA;;;BA)”（该SDDL表示仅仅管理员和SYSTEM有权限访问驱动），事实上，不具有管理员或者SYSTEM权限的攻击者如果直接调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hDevice = CreateFile(<span class="string">&quot;\\\\.\\Device\mydriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>会打开句柄失败，通过GetLastError()会获得错位码5,也即是拒绝访问，的确起到了访问控制的作用。但以上的IoCreateDeviceSecure调用过程中i使用了一个不安全对默认配置，导致了该访问控制可被绕过。</p><h3 id="设备命名空间"><a href="#设备命名空间" class="headerlink" title="设备命名空间"></a>设备命名空间</h3><p>根据微软对WDM（oWindows Driver Model）的<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/controlling-device-namespace-access">介绍</a>，每一个设备对象都会有一个关联的命名空间，该命名空间是设备名称为前缀的，比如以上的设备名称是“\Device\mydriver”，那么，任何以打开任何包含“\Device\mydriver”的文件，比如“\Device\mydriver\testfile”，就意味着打开了设备命名空间“\Device\mydriver”里的“testfile”的文件。对于文件系统，testfile对应一个真实文件。<br>绝大部分的驱动都同时支持打开设备对象和设备对象命名空间里的文件（哪怕该文件可能并不存在），但这个情况下，则需要仔细配置访问控制策略。</p><h3 id="驱动的访问控制"><a href="#驱动的访问控制" class="headerlink" title="驱动的访问控制"></a>驱动的访问控制</h3><p>默认情况下，当调用IoCreateDeviceSecure创建设备对象时候，上层应用尝试访问该设备对象，将会由系统根据配置的SDDL进行权限检查。但是，有一个例外：如果上层应用调用CreateFile访问设备命名空间里的文件时候，系统默认不会进行权限校验，而是交由驱动在IRP_MJ_CREATE处理例程校验，除非驱动在调用IoCreateDeviceSecure设置了参数FILE_DEVICE_SECURE_OPEN，在该情况下，系统才会进行权限校验。<br>可惜，仍然有不少厂商没有配置FILE_DEVICE_SECURE_OPEN参数，同时在IRP_MJ_CREATE处理例程没有进行任何校验，导致低权限的攻击者可以通过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hDevice = CreateFile(<span class="string">&quot;\\\\.\\Device\mydriver\testfile&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>绕过了驱动的访问权限控制。</p><h3 id="漏洞模式检查"><a href="#漏洞模式检查" class="headerlink" title="漏洞模式检查"></a>漏洞模式检查</h3><p>对于这种驱动漏洞模式，如何挖掘？<br>1）通过逆向驱动文件，检查DriverEntry入口函数调用的IoCreateDeviceSecure是否设置了FILE_DEVICE_SECURE_OPEN，如果没有设置，则进一步检查IRP_MJ_CREATE处理例程是否有权限校验：<br>如果IrpSp-&gt;FileObject-&gt;FileName长度不是0，说明上层应用当前是打开设备命名空间里的文件而不是设备对象自身，驱动应返回fail给上层，拒绝访问。<br>否在，则意味者驱动存在了访问控制绕过的漏洞<br>2）通过DeviceTree工具检查</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1）在调用IoCreateDeviceSecure设置FILE_DEVICE_SECURE_OPEN参数，或者<br>2）IRP_MJ_CREATE处理例程检查当期是否是通过设备命名空间的文件打开，如果是，则拒绝访问。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签名校验绕过漏洞</title>
      <link href="/2023/04/19/signature-bypass/"/>
      <url>/2023/04/19/signature-bypass/</url>
      
        <content type="html"><![CDATA[<p>目前，应用一般都会对自研模块的文件进行签名，并在软件启动时候校验签名信息，以保证软件的完整性.一些软件厂商除了使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust">WinVerifyTrust</a>校验签名有效性外，还会对签名的CN字段进行校验，以便确认该文件是否是预期对证书签发（因为攻击者可能使用泄漏到网络对合法签名证书进行签名）。但是，如果仅仅通过判断CN字段是否包含特定字段，则完全可以被绕过。</p><h2 id="工具依赖"><a href="#工具依赖" class="headerlink" title="工具依赖"></a>工具依赖</h2><p>makecert.exe<br>cert2spc.exe<br>pvk2pfx.exe<br>signtool.exe<br>如果已经安装了微软对SDK，那么以上工具将会默认安装，不需要单独安装。推荐通过安装SDK方式进行安装，以避免出现依赖缺少的问题。<br>同时，为了方便使用，建议将以上工具路径添加到系统的环境变量。</p><h2 id="生成自签名的根证书"><a href="#生成自签名的根证书" class="headerlink" title="生成自签名的根证书"></a>生成自签名的根证书</h2><p>makecert.exe -sv D:\mykey.pvk -n “CN&#x3D;my company name” D:\myCert.cer -a SHA256<br>注意：如果CN字段包含特殊字符，比如英文的句号.逗号,，则需要使用转义符号\将整个CN包括起来。<br>比如，-n “CN&#x3D;&quot;XXX Co., Ltd.&quot;”<br>该命令会弹出私钥保护口令，三次</p><h2 id="创建spc文件"><a href="#创建spc文件" class="headerlink" title="创建spc文件"></a>创建spc文件</h2><p>cert2spc.exe D:\myCert.cer D:\mycet.spc</p><h2 id="将公钥和私钥合并成一个pfx格式对s证书文件"><a href="#将公钥和私钥合并成一个pfx格式对s证书文件" class="headerlink" title="将公钥和私钥合并成一个pfx格式对s证书文件"></a>将公钥和私钥合并成一个pfx格式对s证书文件</h2><p>pvk2pfx.exe -pvk D:\mykey.pvk -pi password -spc D:\mycert.spc -pfx D:\mykey.pfx -po password</p><h2 id="签署目标文件"><a href="#签署目标文件" class="headerlink" title="签署目标文件"></a>签署目标文件</h2><p>signtool.exe sign &#x2F;v &#x2F;as &#x2F;fd sha256 &#x2F;f “mykey.pfx” &#x2F;p “password” &#x2F;tr <a href="http://timestamp.digicert.com/">http://timestamp.digicert.com</a> “myfile.exe”</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinVerifyTrust </tag>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
