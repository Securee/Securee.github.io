<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用ESP开发板进行蓝牙的Fuzz测试</title>
      <link href="/2023/04/26/bluetooth-fuzz/"/>
      <url>/2023/04/26/bluetooth-fuzz/</url>
      
        <content type="html"><![CDATA[<h2 id="蓝牙（Bluetooth）介绍"><a href="#蓝牙（Bluetooth）介绍" class="headerlink" title="蓝牙（Bluetooth）介绍"></a>蓝牙（Bluetooth）介绍</h2><p>蓝牙是一个短距离（99%的设备蓝牙传输距离在10米和20米之间，特殊设备可达300米）的无线传输技术，使用2.4Ghz频段，也即是ISM免认证频段上。从1998年对1.0版本到2021年的5.3版本，经历了5代，十几个版本：</p><center> <img src="./bluetooth-fuzz/bluetooth_standar.png" alt="蓝牙发展历史"></center>注：2022年发布了最新的蓝牙5.4标准。从应用和支持协议蓝牙可以划分成经典蓝牙BT和低功耗蓝牙BLE：经典蓝牙一般4.0以下的版本，通常用于数据量较大的传输，比如语音，音乐。经典蓝牙根据传输速度又可以进一步划分为传统蓝牙和高速蓝牙。其中传统蓝牙一般是指蓝牙2.1及以下版本，而高速蓝牙是指2009年后推出对3.0版本，速率可高达24Mbps。<center> <img src="./bluetooth-fuzz/classic_bluetooth.png" alt="经典蓝牙"></center>低功耗蓝牙则是4.0及以上的版本，成本和功耗低是其最大的特点，但速率一般较低，通常用于遥控类设备，比如鼠标键盘，传感器数据传输，比如心跳，血压，温度。<center> <img src="./bluetooth-fuzz/BLE_bluetooth.png" alt="低功耗蓝牙"></center>注：目前不少蓝牙设备都是双模架构，也即是同时支持经典蓝牙和低功耗蓝牙两种模式。<h2 id="经典蓝牙协议栈"><a href="#经典蓝牙协议栈" class="headerlink" title="经典蓝牙协议栈"></a>经典蓝牙协议栈</h2><p>不少设备当前主要使用经典蓝牙进行数据传输，因此本文仅关注经典蓝牙的安全测试。</p><center> <img src="./bluetooth-fuzz/classic_bluetooth_stack.png" alt="蓝牙协议栈"></center>与OSI参考模型类似，蓝牙协议栈也有物理层，链路层，传输层等类似的概念。但对于一个具体对蓝牙设备来说，它可能会根据实际需要仅实现或者使用协议栈对部分协议，但物理层和链路层是必不可少的。而且蓝牙一个关键安全机制--配对就发生在链路层，也即是链路管理协议LMP。<center> <img src="./bluetooth-fuzz/classic_bluetooth_pair.png" alt="配对流程"></center>选择LMP协议进行fuzz测试的意义在于：不需要关注上层的业务逻辑，而且对于可被发现对蓝牙设备来说，都会处理LMP协议的报文。而越上层的协议，与业务越密切，在进行fuzz测试时候可能需要进行一定的操作才能触发相应的代码分支。理想情况下，我们希望能找到0-click控制蓝牙设备或者给蓝牙设备造成DOSg攻击。<h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>与<a href="https://asset-group.github.io/disclosures/braktooth/">BRAKTOOTH</a>一样，我们假设的攻击场景也是：</p><center> <img src="./bluetooth-fuzz/classic_bluetooth_attack_scenario.png" alt="攻击场景"></center>目标设备是被攻击对对象，而攻击者通常拥有自己的PC+定制开发对设备，这里是ESP-WROVER-KIT开发板<center> <img src="./bluetooth-fuzz/ESP-WROVER-KIT.png" alt="ESP32开发板"></center>ESP32开发板可以从京东或者淘宝上购买。之所以选择ESP32开发板，是因为在进行蓝牙协议fuzz的时候，我们需要能够注入畸形报文内容。为了实现这个目的，有两种方法：1 直接修改ESP32的固件代码具体可以参考BRAKTOOTH作者提供的esp32_firmware_patching_framework框架2 在exploit模块下新增自己的功能模块，在运行exploit时候将会自动编译并加载这种方式比较简单，适合小白入手^_^<h2 id="Fuzz环境搭建"><a href="#Fuzz环境搭建" class="headerlink" title="Fuzz环境搭建"></a>Fuzz环境搭建</h2><h3 id="操作系统准备"><a href="#操作系统准备" class="headerlink" title="操作系统准备"></a>操作系统准备</h3><p>BRAKTOOTH支持ubuntu 18.04和20.04,其中ubuntu系统可以安装在物理机上，也支持使用VMware安装，VirtualBox没有测试过。<br>但经过测试发现，如果使用虚拟机，经常会出现找不到USB设备的情况（ESP32开发板通过USB连接测试PC），导致Fuzz测试中断。原因是在Fuzz测试过程中，一方面对USB的响应延迟有要求，另一方面VMware虚拟软件对USB3.1对支持似乎也不是很稳定，经常莫名其妙就异常无法找打USB设备。<br>注：也曾想使用微软的WSL安装ubuntu，然后进行Fuzz，但经过实践，WSL下安装的ubuntu还比不上VMware，直接识别不到ESP32开发板。<br>最后，直接重装一台ubuntu20.04的物理机，从而可以稳定地进行Fuzz测试。</p><h3 id="软件环境准备"><a href="#软件环境准备" class="headerlink" title="软件环境准备"></a>软件环境准备</h3><p>不建议通过git clone方式将BRAKTOOTH从github上克隆下来，而是通过release页码直接<a href="https://github.com/Matheus-Garbelini/braktooth_esp32_bluetooth_classic_attacks/releases/tag/v1.0.1">下载</a>：</p><center> <img src="./bluetooth-fuzz/BRAKTOOTH_release_package.png" alt="直接下载release包"></center>下载后，根据指导进行解压安装即可：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install unzip python3-dev</span><br><span class="line">unzip esp32driver.zip</span><br><span class="line">cd release</span><br><span class="line">python3 firmware.py /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>在执行python3 firmware.py &#x2F;dev&#x2F;ttyUSB0，需要按下开发板上对boot按钮，否在会提上无法刷入。<br>最后，解压wdissector测试套：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zstd</span><br><span class="line">tar -I zstd -xf wdissector.tar.zst</span><br></pre></td></tr></table></figure><h2 id="开始Fuzz测试"><a href="#开始Fuzz测试" class="headerlink" title="开始Fuzz测试"></a>开始Fuzz测试</h2><p>在没有进行任何定制的情况下，这时候，可以直接使用bt_fuzzer进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bin/bt_fuzzer</span><br></pre></td></tr></table></figure><p>以上是有GUI界面的fuzzer：</p><center> <img src="./bluetooth-fuzz/classic_bluetooth_bt_fuzzer.png" alt="bt_fuzzer"></center>界面上有各种配置参数，包括fuzz变异参数，是否实时抓包等。具体可以参考BRAKTOOTH详细[文档](https://github.com/Matheus-Garbelini/braktooth_esp32_bluetooth_classic_attacks/blob/master/README.pdf)<h2 id="定制报文"><a href="#定制报文" class="headerlink" title="定制报文"></a>定制报文</h2><p>HBRAKTOOTH除了提供bt_fuzzer外，也提供了一个漏洞利用框架bin&#x2F;exploiter，比如，可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bin/bt_exploiter --host-port=/dev/ttyUSB1 --target=b0:81:01:96:48:a5 --exploit=lmp_invalid_transport</span><br></pre></td></tr></table></figure><p>执行LMP异常transport报文的fuzz。<br>我们参考exploit开发<a href="https://github.com/Matheus-Garbelini/braktooth_esp32_bluetooth_classic_attacks/blob/master/exploit_modules_tutorial.pdf">文档</a>简单做一个demo。<br>基本上demo只需要实现框架制定对6个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">module_name</span><span class="params">()</span>; <span class="comment">//返回模块名称，其实可以随意返回任意字符串即可</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span> *p)</span>;        <span class="comment">//模块初始化处理，通常是一些参数的设置</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">tx_pre_dissection</span><span class="params">(<span class="type">uint8_t</span> *pkt_buf, <span class="type">int</span> pkt_length, <span class="type">void</span> *p)</span>;  <span class="comment">//发送报文前预处理，比如可以修改报文对内容，可以直接return 0（不进行任何处理）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">tx_post_dissection</span><span class="params">(<span class="type">uint8_t</span> *pkt_buf, <span class="type">int</span> pkt_length, <span class="type">void</span> *p)</span>; <span class="comment">//发送报文后的处理，可以直接return 0（不进行任何处理）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rx_pre_dissection</span><span class="params">(<span class="type">uint8_t</span> *pkt_buf, <span class="type">int</span> pkt_length, <span class="type">void</span> *p)</span>;  <span class="comment">//接收报文前预处理，可以直接return 0（不进行任何处理）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rx_post_dissection</span><span class="params">(<span class="type">uint8_t</span> *pkt_buf, <span class="type">int</span> pkt_length, <span class="type">void</span> *p)</span>; <span class="comment">//接收报文后处理，可以直接return 0（不进行任何处理）</span></span><br></pre></td></tr></table></figure><p>1 切换到目录：wdissector&#x2F;modules&#x2F;exploits&#x2F;bluetooth下，拷贝一个现有cpp文件，并重命名为一个合适的文件，比如lzy_pair.cpp<br>2 打开lzy_pair.cpp<br>  执行以下修改：<br>  1）将以上6个接口前的static关键字删除，否在编译报错<br>  2）按需修改tx_pre_dissection，tx_post_dissection，rx_pre_dissection和x_post_dissection，作为一个简答的demo，可以直接return 0,以便观测蓝牙的配对过程。<br>  <center> <img src="./bluetooth-fuzz/classic_bluetooth_bt_fuzzer_demo_source.png" alt="bt exploit demo"></center><br>3 执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bin/bt_exploiter --list-exploits</span><br></pre></td></tr></table></figure><p>bt_exploiter将会自动编译我们的demo，并列出我们定制模块：</p><center> <img src="./bluetooth-fuzz/classic_bluetooth_bt_fuzzer_demo_list.png" alt="定制demo"></center>4 接着就可以执行我们的demo<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bin/bt_exploiter --host-port=/dev/ttyUSB1 --target=b0:81:01:96:48:a5 --exploit=lzy_pair --iocap 3 --authreq 0 --bounding false</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><center> <img src="./bluetooth-fuzz/classic_bluetooth_bt_fuzzer_demo_run.png" alt="运行定制demo"></center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用ESP开发板和exploit框架，还可以定制各种协议的fuzz，而不仅限于BRAKTOOTH提供的LMP协议。由于蓝牙的规范极其复杂，而各个蓝牙设备厂商都是根据自己对蓝牙规范的理解进行开发的，所以还是可能出现各种各样的漏洞，未来仍然是一个值得继续关注投入的领域。</p>]]></content>
      
      
      <categories>
          
          <category> 模糊测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝牙 </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不安全的Windows驱动配置</title>
      <link href="/2023/04/23/windows-driver-security-sal/"/>
      <url>/2023/04/23/windows-driver-security-sal/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>寻找驱动中的漏洞一直是Windows平台下进行本地提权LPE的重要途径。但是在挖掘驱动的漏洞之前，首先需要解决的一个问题：攻击者（通常是低权限的用户）如何访问该驱动？<br>通常情况下，</p><h3 id="直接可以通过CreateFile打开设备名称"><a href="#直接可以通过CreateFile打开设备名称" class="headerlink" title="直接可以通过CreateFile打开设备名称"></a>直接可以通过CreateFile打开设备名称</h3><p>造成可以直接访问驱动对原因有：<br>1）驱动安装配置文件inf里没有利用<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/sddl-for-device-objects">SDDL</a>设置合适对ACL，或者<br>2）驱动在创建设备对象时候，调用不安全的API:<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">IoCreateDevice</a>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING  RegistryPath)</span><br><span class="line">&#123;</span><br><span class="line">  UNICODE_STRING DeviceName, SymbolicLink,sddlString;</span><br><span class="line">  PDEVICE_OBJECT deviceObject;</span><br><span class="line">  RtlInitUnicodeString(&amp;DeviceName, <span class="string">L&quot;\\Device\\mydriver&quot;</span>);</span><br><span class="line">  RtlInitUnicodeString(&amp;SymbolicLink, <span class="string">L&quot;\\DosDevices\\mydriver&quot;</span>);</span><br><span class="line">  UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">  <span class="comment">//创建设备</span></span><br><span class="line">  IoCreateDevice(DriverObject, <span class="number">65535</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, FALSE, &amp;deviceObject);  </span><br><span class="line">  <span class="comment">//创建设备的符号连接，以便应用层可以通过该符号连接进行访问</span></span><br><span class="line">  IoCreateSymbolicLink(&amp;SymbolicLink, &amp;DeviceName);</span><br><span class="line">  <span class="comment">//IRP处理例程</span></span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = myInternalDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = myDispatchCreate;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = myDispatchClose;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_READ] = myDispatchRead;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = myDispatchWrite;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = mDispatchCleanup;</span><br><span class="line">  DriverObject-&gt;DriverUnload = myUnloadDriver;</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br>3）驱动在创建设备对象虽然调用了安全对API:<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure">IoCreateDeviceSecure</a>，但SDDL参数配置不恰当，如NULL或者SDDL限制范围过宽</p><h3 id="利用上层应用对漏洞进行访问"><a href="#利用上层应用对漏洞进行访问" class="headerlink" title="利用上层应用对漏洞进行访问"></a>利用上层应用对漏洞进行访问</h3><p>至少有三种可能：<br>1）驱动对上层应用存在任意代码执行（低权限），或者<br>2）上层应用的逻辑漏洞，导致第三方应用可以访问驱动，或者<br>3）驱动对访问对象有校验机制，但是可被绕过。比如驱动仅仅校验了进程名，这时候可以简单通过同名进程绕过，如果驱动进行签名校验，那么攻击者还可以尝试通过进程注入方式绕过</p><h3 id="利用设备空间间接访问驱动"><a href="#利用设备空间间接访问驱动" class="headerlink" title="利用设备空间间接访问驱动"></a>利用设备空间间接访问驱动</h3><p>这也是本博客重点要介绍的一个漏洞模式</p><h2 id="安全API-IoCreateDeviceSecure的不安全使用"><a href="#安全API-IoCreateDeviceSecure的不安全使用" class="headerlink" title="安全API IoCreateDeviceSecure的不安全使用"></a>安全API IoCreateDeviceSecure的不安全使用</h2><p>一般情况下，开发者都会进行以下编码，以便对驱动对象对访问实施控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING  RegistryPath)</span><br><span class="line">&#123;</span><br><span class="line">  UNICODE_STRING DeviceName, SymbolicLink,sddlString;</span><br><span class="line">  PDEVICE_OBJECT deviceObject;</span><br><span class="line">  RtlInitUnicodeString(&amp;DeviceName, <span class="string">L&quot;\\Device\\mydriver&quot;</span>);</span><br><span class="line">  RtlInitUnicodeString(&amp;SymbolicLink, <span class="string">L&quot;\\DosDevices\\mydriver&quot;</span>);</span><br><span class="line">  <span class="comment">//设置安全访问对SDDL，以下是最常见的配置，表示仅管理员和SYSTEM对进程可以访问</span></span><br><span class="line">  RtlInitUnicodeString(&amp;sddlString, <span class="string">L&quot;D:P(A;;GA;;;SY)(A;;GA;;;BA)&quot;</span>);</span><br><span class="line">  UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">  <span class="comment">//创建设备</span></span><br><span class="line">  IoCreateDeviceSecure(DriverObject, , &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="literal">NULL</span>, FALSE, &amp;sddlString, <span class="literal">NULL</span>, &amp;deviceObject);  </span><br><span class="line">  <span class="comment">//创建设备的符号连接，以便应用层可以通过该符号连接进行访问</span></span><br><span class="line">  IoCreateSymbolicLink(&amp;SymbolicLink, &amp;DeviceName);</span><br><span class="line">  <span class="comment">//IRP处理例程</span></span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = myInternalDispatchIoctl;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = myDispatchCreate;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = myDispatchClose;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_READ] = myDispatchRead;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = myDispatchWrite;</span><br><span class="line">  DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = myDispatchCleanup;</span><br><span class="line">  DriverObject-&gt;DriverUnload = myUnloadDriver;</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，开发者认为已经调用了安全的API：IoCreateDeviceSecure，同时也设置合理的SDDL：”D:P(A;;GA;;;SY)(A;;GA;;;BA)”（该SDDL表示仅仅管理员和SYSTEM有权限访问驱动），事实上，不具有管理员或者SYSTEM权限的攻击者如果直接调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hDevice = CreateFile(<span class="string">&quot;\\\\.\\Device\mydriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>会打开句柄失败，通过GetLastError()会获得错位码5,也即是拒绝访问，的确起到了访问控制的作用。但以上的IoCreateDeviceSecure调用过程中i使用了一个不安全对默认配置，导致了该访问控制可被绕过。</p><h3 id="设备命名空间"><a href="#设备命名空间" class="headerlink" title="设备命名空间"></a>设备命名空间</h3><p>根据微软对WDM（oWindows Driver Model）的<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/controlling-device-namespace-access">介绍</a>，每一个设备对象都会有一个关联的命名空间，该命名空间是设备名称为前缀的，比如以上的设备名称是“\Device\mydriver”，那么，任何以打开任何包含“\Device\mydriver”的文件，比如“\Device\mydriver\testfile”，就意味着打开了设备命名空间“\Device\mydriver”里的“testfile”的文件。对于文件系统，testfile对应一个真实文件。<br>绝大部分的驱动都同时支持打开设备对象和设备对象命名空间里的文件（哪怕该文件可能并不存在），但这个情况下，则需要仔细配置访问控制策略。</p><h3 id="驱动的访问控制"><a href="#驱动的访问控制" class="headerlink" title="驱动的访问控制"></a>驱动的访问控制</h3><p>默认情况下，当调用IoCreateDeviceSecure创建设备对象时候，上层应用尝试访问该设备对象，将会由系统根据配置的SDDL进行权限检查。但是，有一个例外：如果上层应用调用CreateFile访问设备命名空间里的文件时候，系统默认不会进行权限校验，而是交由驱动在IRP_MJ_CREATE处理例程校验，除非驱动在调用IoCreateDeviceSecure设置了参数FILE_DEVICE_SECURE_OPEN，在该情况下，系统才会进行权限校验。<br>可惜，仍然有不少厂商没有配置FILE_DEVICE_SECURE_OPEN参数，同时在IRP_MJ_CREATE处理例程没有进行任何校验，导致低权限的攻击者可以通过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hDevice = CreateFile(<span class="string">&quot;\\\\.\\Device\mydriver\testfile&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>绕过了驱动的访问权限控制。</p><h3 id="漏洞模式检查"><a href="#漏洞模式检查" class="headerlink" title="漏洞模式检查"></a>漏洞模式检查</h3><p>对于这种驱动漏洞模式，如何挖掘？<br>1）通过逆向驱动文件，检查DriverEntry入口函数调用的IoCreateDeviceSecure是否设置了FILE_DEVICE_SECURE_OPEN，如果没有设置，则进一步检查IRP_MJ_CREATE处理例程是否有权限校验：<br>如果IrpSp-&gt;FileObject-&gt;FileName长度不是0，说明上层应用当前是打开设备命名空间里的文件而不是设备对象自身，驱动应返回fail给上层，拒绝访问。<br>否在，则意味者驱动存在了访问控制绕过的漏洞<br>2）通过DeviceTree工具检查</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1）在调用IoCreateDeviceSecure设置FILE_DEVICE_SECURE_OPEN参数，或者<br>2）IRP_MJ_CREATE处理例程检查当期是否是通过设备命名空间的文件打开，如果是，则拒绝访问。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签名校验绕过漏洞</title>
      <link href="/2023/04/19/signature-bypass/"/>
      <url>/2023/04/19/signature-bypass/</url>
      
        <content type="html"><![CDATA[<p>目前，应用一般都会对自研模块的文件进行签名，并在软件启动时候校验签名信息，以保证软件的完整性.一些软件厂商除了使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust">WinVerifyTrust</a>校验签名有效性外，还会对签名的CN字段进行校验，以便确认该文件是否是预期对证书签发（因为攻击者可能使用泄漏到网络对合法签名证书进行签名）。但是，如果仅仅通过判断CN字段是否包含特定字段，则完全可以被绕过。</p><h2 id="工具依赖"><a href="#工具依赖" class="headerlink" title="工具依赖"></a>工具依赖</h2><p>makecert.exe<br>cert2spc.exe<br>pvk2pfx.exe<br>signtool.exe<br>如果已经安装了微软对SDK，那么以上工具将会默认安装，不需要单独安装。推荐通过安装SDK方式进行安装，以避免出现依赖缺少的问题。<br>同时，为了方便使用，建议将以上工具路径添加到系统的环境变量。</p><h2 id="生成自签名的根证书"><a href="#生成自签名的根证书" class="headerlink" title="生成自签名的根证书"></a>生成自签名的根证书</h2><p>makecert.exe -sv D:\mykey.pvk -n “CN&#x3D;my company name” D:\myCert.cer -a SHA256<br>注意：如果CN字段包含特殊字符，比如英文的句号.逗号,，则需要使用转义符号\将整个CN包括起来。<br>比如，-n “CN&#x3D;&quot;XXX Co., Ltd.&quot;”<br>该命令会弹出私钥保护口令，三次</p><h2 id="创建spc文件"><a href="#创建spc文件" class="headerlink" title="创建spc文件"></a>创建spc文件</h2><p>cert2spc.exe D:\myCert.cer D:\mycet.spc</p><h2 id="将公钥和私钥合并成一个pfx格式对s证书文件"><a href="#将公钥和私钥合并成一个pfx格式对s证书文件" class="headerlink" title="将公钥和私钥合并成一个pfx格式对s证书文件"></a>将公钥和私钥合并成一个pfx格式对s证书文件</h2><p>pvk2pfx.exe -pvk D:\mykey.pvk -pi password -spc D:\mycert.spc -pfx D:\mykey.pfx -po password</p><h2 id="签署目标文件"><a href="#签署目标文件" class="headerlink" title="签署目标文件"></a>签署目标文件</h2><p>signtool.exe sign &#x2F;v &#x2F;as &#x2F;fd sha256 &#x2F;f “mykey.pfx” &#x2F;p “password” &#x2F;tr <a href="http://timestamp.digicert.com/">http://timestamp.digicert.com</a> “myfile.exe”</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinVerifyTrust </tag>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
